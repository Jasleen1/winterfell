use super::{rescue, TreeNode, CYCLE_LENGTH, NUM_HASH_ROUNDS};
use prover::math::field::{BaseElement, FieldElement};

pub fn generate_trace(
    token_seed: BaseElement,
    token_index: usize,
    service_uuid: BaseElement,
    merkle_path: Vec<TreeNode>,
) -> Vec<Vec<BaseElement>> {
    // allocate memory to hold the trace table
    let trace_length = merkle_path.len() * CYCLE_LENGTH;
    let mut trace = vec![
        vec![BaseElement::ZERO; trace_length], // index bits
        vec![BaseElement::ZERO; trace_length], // merkle branch hash state
        vec![BaseElement::ZERO; trace_length], // merkle branch hash state
        vec![BaseElement::ZERO; trace_length], // merkle branch hash state
        vec![BaseElement::ZERO; trace_length], // merkle branch hash state
        vec![BaseElement::ZERO; trace_length], // sub-token hash state
        vec![BaseElement::ZERO; trace_length], // sub-token hash state
        vec![BaseElement::ZERO; trace_length], // sub-token hash state
        vec![BaseElement::ZERO; trace_length], // sub-token hash state
    ];

    // skip the first node in the path since it will be generated by hashing token_seed
    let merkle_path = &merkle_path[1..];

    // if token index is 0, make sure the register will contain at least one non-zero element
    let init_bit = if token_index == 0 {
        BaseElement::ONE
    } else {
        BaseElement::ZERO
    };

    // initialize first state of the computation
    let mut state = [
        init_bit,
        token_seed,
        BaseElement::ZERO,
        BaseElement::ZERO,
        BaseElement::ZERO,
        token_seed,
        service_uuid,
        BaseElement::ZERO,
        BaseElement::ZERO,
    ];
    // copy state into the trace
    for (reg, &val) in state.iter().enumerate() {
        trace[reg][0] = val;
    }

    // execute the transition function for all steps
    for step in 0..(trace_length - 1) {
        // determine which cycle we are in and also where in the cycle we are
        let cycle_num = step / CYCLE_LENGTH;
        let cycle_pos = step % CYCLE_LENGTH;

        // for the remaining 2 rounds, just carry over the values
        // in the first two registers to the next step
        if cycle_pos < NUM_HASH_ROUNDS {
            // for the first 14 steps we copy index bit to the next step
            state[0] = trace[0][step];
            // compute one round of Rescue hash in registers [1..5] for seed
            // hashing and Merkle branch verification
            rescue::apply_round(&mut state[1..5], step);
            // compute one round of Rescue hash in registers [5..9] for salted
            // hash computation
            rescue::apply_round(&mut state[5..9], step);
        } else if cycle_pos == NUM_HASH_ROUNDS {
            // on the 15th step, we move next bit of the index into the first register
            state[0] = BaseElement::from(((token_index >> cycle_num) & 1) as u128);
            // move the results of hashing from registers [1, 2] and copy them to the next step
            state[1] = trace[1][step];
            state[2] = trace[2][step];
            // set all remaining registers to 0
            state[3] = BaseElement::ZERO;
            state[4] = BaseElement::ZERO;
            state[5] = BaseElement::ZERO;
            state[6] = BaseElement::ZERO;
            state[7] = BaseElement::ZERO;
            state[8] = BaseElement::ZERO;
        } else if cycle_pos == NUM_HASH_ROUNDS + 1 {
            // on the 16th step, copy next node of the branch into the appropriate position
            let index_bit = trace[0][step];
            if index_bit == BaseElement::ZERO {
                // if index bit is zero, accumulated hash goes into registers [1, 2],
                // and new branch node goes into registers [3, 4]
                state[1] = trace[1][step];
                state[2] = trace[2][step];
                state[3] = merkle_path[cycle_num].0;
                state[4] = merkle_path[cycle_num].1;
            } else {
                // if index bit is one, accumulated hash goes into registers [3, 4],
                // and new branch nodes goes into registers [1, 2]
                state[1] = merkle_path[cycle_num].0;
                state[2] = merkle_path[cycle_num].1;
                state[3] = trace[1][step];
                state[4] = trace[2][step];
            }
            // index bit is just copied over to the next step
            state[0] = trace[0][step];
            // we also set register [5] to be the same as register 1
            state[5] = state[1];
            // and everything else is set to 0
            state[6] = BaseElement::ZERO;
            state[7] = BaseElement::ZERO;
            state[8] = BaseElement::ZERO;
        }

        // copy state into the trace
        for (reg, &val) in state.iter().enumerate() {
            trace[reg][step + 1] = val;
        }
    }

    trace
}
